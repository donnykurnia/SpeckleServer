{"remainingRequest":"/Users/donnykurnia/data/Projects/upwork/3dbyggeri/glasshouse/SpeckleServer/plugins/admin/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/donnykurnia/data/Projects/upwork/3dbyggeri/glasshouse/SpeckleServer/plugins/admin/src/views/Processor.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/donnykurnia/data/Projects/upwork/3dbyggeri/glasshouse/SpeckleServer/plugins/admin/src/views/Processor.vue","mtime":1609071089432},{"path":"/Users/donnykurnia/data/Projects/upwork/3dbyggeri/glasshouse/SpeckleServer/plugins/admin/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/donnykurnia/data/Projects/upwork/3dbyggeri/glasshouse/SpeckleServer/plugins/admin/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/donnykurnia/data/Projects/upwork/3dbyggeri/glasshouse/SpeckleServer/plugins/admin/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\nimport debounce from 'lodash.debounce'\nimport ProcessorBlock from '../components/ProcessorBlock.vue'\nimport DetailDescription from '../components/DetailDescription.vue'\nimport VueJsonPretty from 'vue-json-pretty'\n\nimport Axios from 'axios'\n\nexport default {\n  name: 'ProcessorView',\n  components: {\n    ProcessorBlock,\n    DetailDescription,\n    VueJsonPretty,\n  },\n  computed: {\n    lambdas( ) {\n      return this.$store.state.lambdas.sort((x, y) => (x.name > y.name) ? 1 : -1)\n    },\n    shareLink( ) {\n      let copy = Object.assign({}, this.processor)\n\n      delete copy._id\n      delete copy.owner\n      delete copy.private\n      delete copy.canRead\n      delete copy.canWrite\n      delete copy.anonymousComments\n      delete copy.comments\n\n      return window.location.origin + \"/#/processors/import?processor=\" + btoa(encodeURI(JSON.stringify(copy)))\n    },\n    successRun( ) {\n      if (this.blockStatus.length > 0 && this.blockStatus.length == this.processor.blocks.length)\n        return this.blockStatus[this.blockStatus.length - 1] == 'success'\n\n      return false\n    },\n    responseObject( ) {\n      if (!this.successRun)\n        return null\n\n      if (typeof this.blockOutput[this.blockOutput.length - 1] == 'string')\n        return this.blockOutput[this.blockOutput.length - 1]\n      else if (Object.keys(this.blockOutput[this.blockOutput.length - 1]).length <= 10)\n        return this.removeArraysRecursive( this.blockOutput[this.blockOutput.length - 1] )\n      else\n      {\n        let bar = {}\n        for ( let key in this.blockOutput[this.blockOutput.length - 1] ) {\n          bar[key] = this.blockOutput[this.blockOutput.length - 1][key]\n\n          if (Object.keys(bar).length > 10)\n            break\n        }\n        bar['_hidden'] = `... (${Object.keys(this.blockOutput[this.blockOutput.length - 1]).length - 10} more objects)`\n        return this.removeArraysRecursive( bar )\n      }\n    }\n  },\n  data( ) {\n    return {\n      initInput: \"\",\n\n      isRunning: false,\n\n      id: \"\",\n      processor: null,\n\n      blockStatus: [ ],\n      blockOutput: [ ],\n      \n      toRequest: [ ],\n      requestBuckets: [ ],\n      isRequesting: false,\n      pauseRequesting: false,\n      bucketInProgress: false,\n    }\n  },\n  mutations: {\n\n  },\n  methods: {\n    async runProcessor ( ) {\n      if (this.isRunning)\n        return\n\n      this.isRunning = true\n      \n      var blockInput = this.initInput\n      var i = 0\n\n      if (this.successRun)\n      {\n        this.blockOutput.splice(0, this.blockOutput.length)\n        this.blockStatus.splice(0, this.blockStatus.length)\n      }\n      else if (this.blockStatus.length > 0)\n      {\n        i = this.blockStatus.filter(x => x == 'success').length\n\n        if (i > 0)\n          blockInput = this.blockOutput[i - 1]\n\n        this.blockOutput.splice(i, this.blockOutput.length - i)\n        this.blockStatus.splice(i, this.blockStatus.length - i)\n      }\n\n      for (; i < this.processor.blocks.length; i++)\n      {\n        this.blockStatus.push('running')\n\n        var token = this.getToken(this.processor.blocks[i])\n\n        var params = this.processor.params[i] ? this.processor.params[i] : new Object\n        \n        if (this.processor.blocks[i].allowBucketing && blockInput.constructor === Array)\n        {\n          // Try to chunk the payload if it is an array\n          var bucket = [ ],\n            maxReq = 250 // magic number; maximum objects to request in a bucket\n\n          var output = [ ]\n\n          for (let j = 0; j < blockInput.length; j++)\n          {\n            bucket.push( blockInput[j] )\n\n            if ( j % maxReq === 0 && j !== 0 ) {\n              try\n              {\n                let result = await this.callLambda( this.processor.blocks[i].function, bucket, params, token )\n                if (result.data.constructor === Array)\n                  output.push(...result.data)\n                else\n                  output.push(result.data)\n              }\n              catch (err)\n              {\n                this.blockStatus.pop()\n                this.blockStatus.push('error')\n                this.blockOutput.push(err.response.data)\n                this.isRunning = false\n                return\n              }\n\n              bucket = [ ]\n            }\n          }\n\n          if ( bucket.length > 0 ) {\n            try\n            {\n              let result = await this.callLambda( this.processor.blocks[i].function, bucket, params, token )\n\n              if (result.data.constructor === Array)\n                output.push(...result.data)\n              else\n                output.push(result.data)\n            }\n            catch (err) \n            {\n              this.blockStatus.pop()\n              this.blockStatus.push('error')\n              this.blockOutput.push(err.response.data)\n              this.isRunning = false\n              return\n            }\n\n            bucket = [ ]\n          }\n\n          this.blockStatus.pop()\n          this.blockStatus.push('success')\n          this.blockOutput.push(output)\n          blockInput = output\n        }\n        else\n        {\n          try\n          {\n            let result = await this.callLambda( this.processor.blocks[i].function, blockInput, params, token )\n            this.blockStatus.pop()\n            this.blockStatus.push('success')\n            this.blockOutput.push(result.data)\n            blockInput = result.data\n          }\n          catch (err) \n          {\n            this.blockStatus.pop()\n            this.blockStatus.push('error')\n            this.blockOutput.push(err.response.data)\n            this.isRunning = false\n            return\n          }\n        }\n      }\n\n      this.isRunning = false\n    },\n\n    callLambda( func, input, params, token ) {\n      return new Promise((resolve, reject) => {\n        Axios({\n          method: 'POST',\n          url: `.netlify/functions/${func}`,\n          baseURL: location.protocol + '//' + location.host,\n          data: {\n            baseUrl: this.$store.state.server,\n            token: token,\n            input: input,\n            parameters: params,\n          },\n        })\n          .then( res => resolve(res) )\n          .catch ( err => reject(err) )\n      })\n    },\n\n    rerunBlock ( index ) {\n      if (this.isRunning)\n        return\n\n      this.blockOutput.splice(index, this.blockOutput.length - index)\n      this.blockStatus.splice(index, this.blockStatus.length - index)\n\n      this.runProcessor()\n    },\n\n    addBlock ( sender ) {\n      if (sender != null)\n      {\n        this.processor.blocks.push( sender )\n        this.processor.params.push({})\n      }\n      this.updateBlock ( )\n    },\n\n    removeBlock ( index ) {\n      this.blockOutput.splice(index, this.blockOutput.length - index)\n      this.blockStatus.splice(index, this.blockStatus.length - index)\n\n      this.processor.params.splice(index, 1)\n      this.processor.blocks.splice(index, 1)\n      this.updateBlock ( )\n    },\n\n    updateParam ( payload ) {\n      this.blockOutput.splice(payload.index, this.blockOutput.length - payload.index)\n      this.blockStatus.splice(payload.index, this.blockStatus.length - payload.index)\n      \n      this.processor.params[payload.index] = Object.assign({}, ...\n        Object.entries(payload.params).filter(([k,v]) => {\n          if (v === null)\n            return false\n\n          if (typeof v == 'boolean')\n            return v\n          \n          return Object.keys(v).length > 0\n        }).map(([k,v]) => ({[k]:v}))\n      )\n      this.updateBlock ( )\n    },\n\n    updateName( args ) {\n      this.processor.name = args.text\n      this.$store.dispatch( 'updateProcessor', { _id: this.id, name: this.processor.name } )\n    },\n\n    updateTags: debounce( function( e ) {\n      this.$store.dispatch( 'updateProcessor', { _id: this.id, tags: this.processor.tags } )\n    }, 1000 ),\n\n    updateBlock ( ) {\n      this.$store.dispatch('updateProcessor',\n        {\n          _id: this.id,\n          blocks: this.processor.blocks,\n          params: this.processor.params,\n        }\n      )\n    },\n    \n    removeArraysRecursive( foo ) {\n      let bar = {}\n\n      if (typeof foo == 'string')\n        return foo\n\n      for ( let key in foo ) {\n        if ( !foo.hasOwnProperty( key ) ) continue\n\n        if ( Array.isArray( foo[ key ] ) ) {\n          /*DO FUCKALL */\n          if( foo[key].length < 3 )\n            bar[key] = foo[key]\n          else {\n            bar[key] = [ ...foo[key].slice(0, 3), `... (${foo[key].length - 3} more values)` ]\n          }\n        } else if ( typeof foo[ key ] === 'object' && foo[ key ] !== null ) {\n          bar[ key ] = this.removeArraysRecursive( foo[ key ] )\n        } else {\n          bar[ key ] = foo[ key ]\n        }\n      }\n      return bar\n    },\n\n    getToken( block ) {\n      if (block.msal)\n      {\n        var tokenID = 'msal|' + block.msal.clientId\n\n        if (this.$store.state.tokens.hasOwnProperty(tokenID))\n          return this.$store.state.tokens[tokenID]\n      }\n\n      return Axios.defaults.headers.common[ 'Authorization' ]\n    }\n  },\n  activated( ) {\n    this.id = this.$route.params.processorId\n\n    if (this.id == 'import')\n    {\n      var parsed = null\n      \n      try\n      {\n        console.log(this.$route.query.processor)\n        parsed = JSON.parse(decodeURI(atob(this.$route.query.processor)))\n      }\n      catch\n      {\n        console.log( 'failed to import' )\n        this.$router.push( `/processors/` )\n      }\n\n      if (parsed)\n      {\n        parsed.name = 'Imported: ' + parsed.name\n        this.$store.dispatch( 'createProcessor', parsed )\n          .then( res => {\n            this.processor = res\n            this.id = this.processor._id\n            this.$router.replace( `${this.id}` )\n\n            console.log( 'activated' )\n            this.isLoading = false\n          })\n          .catch( err => {\n            console.log( 'failed to import' )\n            this.$router.push( `/processors/` )\n          })\n      }\n    }\n    else\n    {\n      this.$store.dispatch('getProcessor', { _id: this.id })\n        .then( res => {\n          if (res == null)\n            this.$router.push( `/processors/` )\n          \n          this.processor = res\n\n          console.log( 'activated' )\n        })\n    }\n  },\n  deactivated( ) {\n    this.processor = null\n\n    this.blockStatus.splice(0, this.blockStatus.length) \n    this.blockOutput.splice(0, this.blockOutput.length) \n    \n    console.log( 'de-activated' )\n  },\n}\n",{"version":3,"sources":["Processor.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuHA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA","file":"Processor.vue","sourceRoot":"src/views","sourcesContent":["<template>\n  <v-container grid-list-xl>\n    <div style='position: absolute; top:0; left: 0; width: 100%;'>\n      <v-progress-linear :indeterminate=\"true\" v-show='!processor' height='2' class='ma-0'></v-progress-linear>\n    </div>\n    <v-layout row wrap v-if=\"processor\">\n      <v-flex xs12>\n        <v-card class=\"pa-3\">\n          <v-layout row wrap>\n            <v-flex xs12 class='display-1 font-weight-light text-capitalize my-5'>\n              <editable-span :text='processor.name' @update='updateName'></editable-span>\n            </v-flex>\n            <v-flex xs12 class='ma-0 py-0 mb-2'>\n              <v-combobox :menu-props='{\"maxHeight\":0, \"zIndex\":\"0\"}' @input='updateTags' v-model=\"processor.tags\" :items='processor.tags' hint='add or remove tags' solo persistent-hint small-chips deletable-chips multiple tags>\n                <template v-slot:no-data>processor has no tags.</template>\n              </v-combobox>\n            </v-flex>\n          </v-layout>\n          <v-card-actions>\n            <v-dialog\n              max-width=\"500\">\n              <template v-slot:activator=\"{ on }\">\n                <v-btn round small depressed v-on=\"on\">\n                  <v-icon>share</v-icon>\n                  <span class=\"mx-2\">share</span>\n                </v-btn>\n              </template>\n              <v-card>\n                <v-card-title>\n                  <span class='font-weight-light'>\n                    Share link\n                  </span>\n                </v-card-title>\n                <v-card-text>\n                  <v-text-field :readonly=\"true\" v-model=\"shareLink\" class='font-weight-light'></v-text-field>\n                </v-card-text>\n              </v-card>\n            </v-dialog>\n          </v-card-actions>\n        </v-card>\n      </v-flex>\n      <v-flex xs12>\n        <v-card class=\"my-4\">\n          <detail-description :resource='processor'></detail-description>\n        </v-card>\n      </v-flex>\n      <v-flex>\n        <v-card>\n          <v-flex mb-3 class=\"pa-4\">\n            <v-icon class=\"mr-2\">\n              code\n            </v-icon>\n            <span class='title font-weight-light mr-2'>\n              Processor\n            </span>\n          </v-flex>\n        </v-card>\n        <v-flex xs12 v-for='(block, index) in processor.blocks' :key='index'>\n          <processor-block\n            :index='index'\n            :block='block'\n            :output='blockOutput[index]'\n            :status='blockStatus[index]'\n            :params='processor.params[index]'\n            v-on:remove-block=\"removeBlock\"\n            v-on:update-param=\"updateParam\"\n            v-on:rerun-block=\"rerunBlock\"/>\n        </v-flex>\n        <v-flex xs12 mb-3 pa-0 v-if='processor.blocks.length > 0'>\n          <v-card>\n            <v-flex ma-0 pa-3>\n              <v-icon small class=\"mr-2\">\n                receipt\n              </v-icon>\n              <span class='font-weight-light mr-2'>\n                Output\n              </span>\n            </v-flex>\n            <v-divider v-if=\"successRun\"></v-divider>\n            <v-flex v-if=\"successRun\" pa-3>\n              <vue-json-pretty :data='responseObject' :deep='1' highlight-mouseover-node show-length :show-line='false' :show-double-quotes='false'>\n              </vue-json-pretty>\n            </v-flex>\n          </v-card>\n        </v-flex>\n        <v-card>\n          <v-flex xs12>\n            <v-autocomplete\n              return-object\n              :items=\"lambdas\"\n              item-text=\"name\"\n              item-value=\"name\"\n              v-on:input=\"addBlock\"\n              label=\"Add new block\">\n              <template slot=\"selection\">\n                {{null}}\n              </template>\n              <template slot=\"item\" slot-scope=\"lambdas\">\n                <v-icon class=\"mr-2\">\n                  {{lambdas.item.icon ? lambdas.item.icon : 'code'}}\n                </v-icon>\n                {{lambdas.item.name}}\n              </template>\n            </v-autocomplete>\n          </v-flex>\n        </v-card>\n      </v-flex>\n    </v-layout>\n    <v-btn color=\"primary\" dark fixed large bottom right fab @click=\"runProcessor\">\n      <v-progress-circular v-if=\"isRunning\" indeterminate>\n      </v-progress-circular>\n      <v-icon v-else>\n        {{this.successRun ? \"replay\" : \"play_arrow\"}}\n      </v-icon>\n    </v-btn>\n  </v-container>\n</template>\n<script>\n\nimport debounce from 'lodash.debounce'\nimport ProcessorBlock from '../components/ProcessorBlock.vue'\nimport DetailDescription from '../components/DetailDescription.vue'\nimport VueJsonPretty from 'vue-json-pretty'\n\nimport Axios from 'axios'\n\nexport default {\n  name: 'ProcessorView',\n  components: {\n    ProcessorBlock,\n    DetailDescription,\n    VueJsonPretty,\n  },\n  computed: {\n    lambdas( ) {\n      return this.$store.state.lambdas.sort((x, y) => (x.name > y.name) ? 1 : -1)\n    },\n    shareLink( ) {\n      let copy = Object.assign({}, this.processor)\n\n      delete copy._id\n      delete copy.owner\n      delete copy.private\n      delete copy.canRead\n      delete copy.canWrite\n      delete copy.anonymousComments\n      delete copy.comments\n\n      return window.location.origin + \"/#/processors/import?processor=\" + btoa(encodeURI(JSON.stringify(copy)))\n    },\n    successRun( ) {\n      if (this.blockStatus.length > 0 && this.blockStatus.length == this.processor.blocks.length)\n        return this.blockStatus[this.blockStatus.length - 1] == 'success'\n\n      return false\n    },\n    responseObject( ) {\n      if (!this.successRun)\n        return null\n\n      if (typeof this.blockOutput[this.blockOutput.length - 1] == 'string')\n        return this.blockOutput[this.blockOutput.length - 1]\n      else if (Object.keys(this.blockOutput[this.blockOutput.length - 1]).length <= 10)\n        return this.removeArraysRecursive( this.blockOutput[this.blockOutput.length - 1] )\n      else\n      {\n        let bar = {}\n        for ( let key in this.blockOutput[this.blockOutput.length - 1] ) {\n          bar[key] = this.blockOutput[this.blockOutput.length - 1][key]\n\n          if (Object.keys(bar).length > 10)\n            break\n        }\n        bar['_hidden'] = `... (${Object.keys(this.blockOutput[this.blockOutput.length - 1]).length - 10} more objects)`\n        return this.removeArraysRecursive( bar )\n      }\n    }\n  },\n  data( ) {\n    return {\n      initInput: \"\",\n\n      isRunning: false,\n\n      id: \"\",\n      processor: null,\n\n      blockStatus: [ ],\n      blockOutput: [ ],\n      \n      toRequest: [ ],\n      requestBuckets: [ ],\n      isRequesting: false,\n      pauseRequesting: false,\n      bucketInProgress: false,\n    }\n  },\n  mutations: {\n\n  },\n  methods: {\n    async runProcessor ( ) {\n      if (this.isRunning)\n        return\n\n      this.isRunning = true\n      \n      var blockInput = this.initInput\n      var i = 0\n\n      if (this.successRun)\n      {\n        this.blockOutput.splice(0, this.blockOutput.length)\n        this.blockStatus.splice(0, this.blockStatus.length)\n      }\n      else if (this.blockStatus.length > 0)\n      {\n        i = this.blockStatus.filter(x => x == 'success').length\n\n        if (i > 0)\n          blockInput = this.blockOutput[i - 1]\n\n        this.blockOutput.splice(i, this.blockOutput.length - i)\n        this.blockStatus.splice(i, this.blockStatus.length - i)\n      }\n\n      for (; i < this.processor.blocks.length; i++)\n      {\n        this.blockStatus.push('running')\n\n        var token = this.getToken(this.processor.blocks[i])\n\n        var params = this.processor.params[i] ? this.processor.params[i] : new Object\n        \n        if (this.processor.blocks[i].allowBucketing && blockInput.constructor === Array)\n        {\n          // Try to chunk the payload if it is an array\n          var bucket = [ ],\n            maxReq = 250 // magic number; maximum objects to request in a bucket\n\n          var output = [ ]\n\n          for (let j = 0; j < blockInput.length; j++)\n          {\n            bucket.push( blockInput[j] )\n\n            if ( j % maxReq === 0 && j !== 0 ) {\n              try\n              {\n                let result = await this.callLambda( this.processor.blocks[i].function, bucket, params, token )\n                if (result.data.constructor === Array)\n                  output.push(...result.data)\n                else\n                  output.push(result.data)\n              }\n              catch (err)\n              {\n                this.blockStatus.pop()\n                this.blockStatus.push('error')\n                this.blockOutput.push(err.response.data)\n                this.isRunning = false\n                return\n              }\n\n              bucket = [ ]\n            }\n          }\n\n          if ( bucket.length > 0 ) {\n            try\n            {\n              let result = await this.callLambda( this.processor.blocks[i].function, bucket, params, token )\n\n              if (result.data.constructor === Array)\n                output.push(...result.data)\n              else\n                output.push(result.data)\n            }\n            catch (err) \n            {\n              this.blockStatus.pop()\n              this.blockStatus.push('error')\n              this.blockOutput.push(err.response.data)\n              this.isRunning = false\n              return\n            }\n\n            bucket = [ ]\n          }\n\n          this.blockStatus.pop()\n          this.blockStatus.push('success')\n          this.blockOutput.push(output)\n          blockInput = output\n        }\n        else\n        {\n          try\n          {\n            let result = await this.callLambda( this.processor.blocks[i].function, blockInput, params, token )\n            this.blockStatus.pop()\n            this.blockStatus.push('success')\n            this.blockOutput.push(result.data)\n            blockInput = result.data\n          }\n          catch (err) \n          {\n            this.blockStatus.pop()\n            this.blockStatus.push('error')\n            this.blockOutput.push(err.response.data)\n            this.isRunning = false\n            return\n          }\n        }\n      }\n\n      this.isRunning = false\n    },\n\n    callLambda( func, input, params, token ) {\n      return new Promise((resolve, reject) => {\n        Axios({\n          method: 'POST',\n          url: `.netlify/functions/${func}`,\n          baseURL: location.protocol + '//' + location.host,\n          data: {\n            baseUrl: this.$store.state.server,\n            token: token,\n            input: input,\n            parameters: params,\n          },\n        })\n          .then( res => resolve(res) )\n          .catch ( err => reject(err) )\n      })\n    },\n\n    rerunBlock ( index ) {\n      if (this.isRunning)\n        return\n\n      this.blockOutput.splice(index, this.blockOutput.length - index)\n      this.blockStatus.splice(index, this.blockStatus.length - index)\n\n      this.runProcessor()\n    },\n\n    addBlock ( sender ) {\n      if (sender != null)\n      {\n        this.processor.blocks.push( sender )\n        this.processor.params.push({})\n      }\n      this.updateBlock ( )\n    },\n\n    removeBlock ( index ) {\n      this.blockOutput.splice(index, this.blockOutput.length - index)\n      this.blockStatus.splice(index, this.blockStatus.length - index)\n\n      this.processor.params.splice(index, 1)\n      this.processor.blocks.splice(index, 1)\n      this.updateBlock ( )\n    },\n\n    updateParam ( payload ) {\n      this.blockOutput.splice(payload.index, this.blockOutput.length - payload.index)\n      this.blockStatus.splice(payload.index, this.blockStatus.length - payload.index)\n      \n      this.processor.params[payload.index] = Object.assign({}, ...\n        Object.entries(payload.params).filter(([k,v]) => {\n          if (v === null)\n            return false\n\n          if (typeof v == 'boolean')\n            return v\n          \n          return Object.keys(v).length > 0\n        }).map(([k,v]) => ({[k]:v}))\n      )\n      this.updateBlock ( )\n    },\n\n    updateName( args ) {\n      this.processor.name = args.text\n      this.$store.dispatch( 'updateProcessor', { _id: this.id, name: this.processor.name } )\n    },\n\n    updateTags: debounce( function( e ) {\n      this.$store.dispatch( 'updateProcessor', { _id: this.id, tags: this.processor.tags } )\n    }, 1000 ),\n\n    updateBlock ( ) {\n      this.$store.dispatch('updateProcessor',\n        {\n          _id: this.id,\n          blocks: this.processor.blocks,\n          params: this.processor.params,\n        }\n      )\n    },\n    \n    removeArraysRecursive( foo ) {\n      let bar = {}\n\n      if (typeof foo == 'string')\n        return foo\n\n      for ( let key in foo ) {\n        if ( !foo.hasOwnProperty( key ) ) continue\n\n        if ( Array.isArray( foo[ key ] ) ) {\n          /*DO FUCKALL */\n          if( foo[key].length < 3 )\n            bar[key] = foo[key]\n          else {\n            bar[key] = [ ...foo[key].slice(0, 3), `... (${foo[key].length - 3} more values)` ]\n          }\n        } else if ( typeof foo[ key ] === 'object' && foo[ key ] !== null ) {\n          bar[ key ] = this.removeArraysRecursive( foo[ key ] )\n        } else {\n          bar[ key ] = foo[ key ]\n        }\n      }\n      return bar\n    },\n\n    getToken( block ) {\n      if (block.msal)\n      {\n        var tokenID = 'msal|' + block.msal.clientId\n\n        if (this.$store.state.tokens.hasOwnProperty(tokenID))\n          return this.$store.state.tokens[tokenID]\n      }\n\n      return Axios.defaults.headers.common[ 'Authorization' ]\n    }\n  },\n  activated( ) {\n    this.id = this.$route.params.processorId\n\n    if (this.id == 'import')\n    {\n      var parsed = null\n      \n      try\n      {\n        console.log(this.$route.query.processor)\n        parsed = JSON.parse(decodeURI(atob(this.$route.query.processor)))\n      }\n      catch\n      {\n        console.log( 'failed to import' )\n        this.$router.push( `/processors/` )\n      }\n\n      if (parsed)\n      {\n        parsed.name = 'Imported: ' + parsed.name\n        this.$store.dispatch( 'createProcessor', parsed )\n          .then( res => {\n            this.processor = res\n            this.id = this.processor._id\n            this.$router.replace( `${this.id}` )\n\n            console.log( 'activated' )\n            this.isLoading = false\n          })\n          .catch( err => {\n            console.log( 'failed to import' )\n            this.$router.push( `/processors/` )\n          })\n      }\n    }\n    else\n    {\n      this.$store.dispatch('getProcessor', { _id: this.id })\n        .then( res => {\n          if (res == null)\n            this.$router.push( `/processors/` )\n          \n          this.processor = res\n\n          console.log( 'activated' )\n        })\n    }\n  },\n  deactivated( ) {\n    this.processor = null\n\n    this.blockStatus.splice(0, this.blockStatus.length) \n    this.blockOutput.splice(0, this.blockOutput.length) \n    \n    console.log( 'de-activated' )\n  },\n}\n</script>\n<style scoped lang='scss'>\n</style>\n"]}]}