{"remainingRequest":"/Users/donnykurnia/data/Projects/upwork/3dbyggeri/glasshouse/SpeckleServer/plugins/admin/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/donnykurnia/data/Projects/upwork/3dbyggeri/glasshouse/SpeckleServer/plugins/admin/src/components/ViewerObjectGroups.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/donnykurnia/data/Projects/upwork/3dbyggeri/glasshouse/SpeckleServer/plugins/admin/src/components/ViewerObjectGroups.vue","mtime":1609071089418},{"path":"/Users/donnykurnia/data/Projects/upwork/3dbyggeri/glasshouse/SpeckleServer/plugins/admin/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/donnykurnia/data/Projects/upwork/3dbyggeri/glasshouse/SpeckleServer/plugins/admin/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/donnykurnia/data/Projects/upwork/3dbyggeri/glasshouse/SpeckleServer/plugins/admin/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport get from 'lodash.get'\nexport default {\n  name: 'ObjectGroups',\n  props: {\n    groupKeySeed: {\n      type: String,\n      default: null\n    }\n  },\n  watch: {\n    groupKeySeed( newVal, oldVal ) {\n      if ( newVal !== null && this.init === false ) {\n        this.init = true\n        this.groupKey = newVal\n      }\n    },\n    groupKey: {\n      immediate: true,\n      handler( newVal, oldVal ) {\n        if ( newVal === null ) return\n        console.log( \"TEST \" + newVal )\n        this.filterText = ''\n        window.renderer.showObjects( [ ] )\n\n        window.renderer.resetColors( { propagateLegend: true } )\n\n        if ( this.structuralKeys.indexOf( newVal ) !== -1 ) {\n          console.log( 'its a structural propertyyyyyy' )\n          this.generateGroups( 'structural.result.' + newVal )\n          this.appendInfoToUrl( \"groups\", { key: newVal } )\n          window.renderer.colorByVertexArray( { propertyName: newVal, colors: this.rainbowColors } )\n          return\n        }\n\n        if ( newVal ) {\n          this.generateGroups( newVal )\n          this.appendInfoToUrl( \"groups\", { key: newVal } )\n          window.renderer.colorByProperty( { propertyName: newVal, propagateLegend: true, colors: this.coolColors } )\n        }\n\n        if ( newVal === undefined ) {\n          this.appendInfoToUrl( \"groups\", null )\n          window.renderer.showObjects( [ ] )\n        }\n\n      }\n    },\n    legend: {\n      handler: function ( newVal, oldVal ) {\n        if ( !newVal ) return\n        this.min = this.$store.state.legend.min\n        this.max = this.$store.state.legend.max\n        this.selectedRange = [ this.min, this.max ]\n      },\n      deep: true\n    }\n  },\n  computed: {\n    myFilteredGroups( ) {\n      let filteredGroups = {}\n      if ( !this.filterText || this.filterText === '' ) return this.myGroups\n      return this.myGroups.filter( gr => gr.name.toLowerCase( ).includes( this.filterText.toLowerCase( ) ) )\n    },\n    orphanGroup( ) {\n      let orphans = this.myGroups.find( gr => gr.name === \"Orphaned Objects\" )\n      return orphans\n      // return this.myGroups[ 0 ] ? this.myGroups[ 0 ] : null\n    },\n    keys( ) {\n      return this.$store.getters.objectPropertyKeys\n    },\n    allKeys( ) {\n      return [ ...this.$store.getters.objectPropertyKeys.allKeys, ...this.$store.getters.structuralKeys ]\n    },\n    structuralKeys( ) {\n      return this.$store.getters.structuralKeys\n    },\n    isTextProperty( ) {\n      return this.keys.stringKeys.indexOf( this.groupKey ) !== -1\n    },\n    legend( ) {\n      return this.$store.state.legend\n    }\n  },\n  data( ) {\n    return {\n      groupKey: null,\n      myGroups: [ ],\n      loading: false,\n      filterText: null,\n      selectedRange: [ 0, 1000 ],\n      rainbowColors: [ \"#9400D3\", \"#4B0082\", \"#0000FF\", \"#00FF00\", \"#FFFF00\", \"#FF7F00\", \"#FF0000\" ],\n      coolColors: [ \"#0A66FF\", \"#FF008A\" ],\n      init: false\n    }\n  },\n  methods: {\n    generateGroups( key ) {\n      this.myGroups = [ ]\n      this.loading = true\n\n      let groups = { orphans: { key: 'orphans', name: 'Orphaned Objects', objects: [ ], visible: true, isolated: false } }\n\n      if ( this.isTextProperty ) {\n\n        this.$store.state.objects.forEach( ( obj, index ) => {\n          let propValue = get( obj.properties, key )\n          if ( propValue ) {\n            // if we have the group already\n            if ( groups.hasOwnProperty( propValue ) ) {\n              groups[ propValue ].objects.push( obj._id )\n            } else {\n              groups[ propValue ] = {\n                key: key,\n                name: propValue,\n                objects: [ obj._id ],\n                visible: true,\n                isolated: false\n              }\n            }\n          } else {\n            groups.orphans.objects.push( obj._id )\n          }\n          if ( index === this.$store.state.objects.length - 1 ) {\n            this.loading = false\n          }\n        } )\n\n      }\n      Object.keys( groups ).forEach( key => this.myGroups.push( groups[ key ] ) )\n    },\n    filterProp( ) {\n      let objIds = [ ]\n\n      this.$store.state.objects.forEach( ( obj, index ) => {\n        let propValue = get( obj.properties, this.groupKey )\n        if ( propValue )\n          if ( propValue >= this.selectedRange[ 0 ] && propValue <= this.selectedRange[ 1 ] )\n            objIds.push( obj._id )\n\n\n        if ( index === this.$store.state.objects.length - 1 ) {\n          if ( this.myGroups[ 0 ] && this.myGroups[ 0 ].visible )\n            objIds = [ ...objIds, ...this.myGroups[ 0 ].objects ]\n\n          window.renderer.isolateObjects( objIds )\n          window.renderer.resetColors( { propagateLegend: false } )\n          window.renderer.colorByProperty( { propertyName: this.groupKey, propagateLegend: false, colors: this.coolColors } )\n        }\n      } )\n    },\n    toggleVisible( groupName ) {\n      let group = this.myGroups.find( gr => gr.name === groupName )\n      if ( group.visible ) {\n        window.renderer.hideObjects( group.objects )\n        group.visible = false\n      } else {\n        window.renderer.showObjects( group.objects )\n        group.visible = true\n      }\n    },\n    toggleIsolation( groupName ) {\n      let group = this.myGroups.find( gr => gr.name === groupName )\n      if ( group.isolated ) {\n        window.renderer.showObjects( [ ] )\n        group.isolated = false\n      } else {\n        group.visible = true\n        group.isolated = true\n        window.renderer.isolateObjects( group.objects )\n      }\n\n      this.myGroups.forEach( gr => {\n        if ( gr.name === groupName ) return\n        if ( group.isolated ) {\n          gr.isolated = false\n          gr.visible = false\n        } else {\n          gr.visible = true\n          window.renderer.showObjects( gr.objects )\n        }\n      } )\n    },\n\n  },\n  mounted( ) {\n    // console.log( 'mounted - object groups' )\n    // console.log( this.groupKeySeed )\n    // if ( this.groupKeySeed !== null ) {\n    //   this.groupKey = this.groupKeySeed\n    // }\n  },\n  activated( ) {\n    if ( this.groupKey ) {\n      this.appendInfoToUrl( \"groups\", { key: this.groupKey } )\n    }\n  }\n}\n\n",{"version":3,"sources":["ViewerObjectGroups.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"ViewerObjectGroups.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <v-layout row wrap>\n    <v-flex xs12>\n      <v-autocomplete box label='select a property to group objects by' clearable v-model=\"groupKey\" :items=\"allKeys\"></v-autocomplete>\n      <v-text-field v-show='isTextProperty' label=\"filter\" v-model='filterText' hint='Search through the layers below' append-icon='filter_list' clearable></v-text-field>\n    </v-flex>\n    <!--     <v-flex xs12 v-if='$store.getters[\"hasStructuralProperties\"]'>\n      <v-btn block>Show structural</v-btn>\n    </v-flex> -->\n    <v-flex xs12 v-if='isTextProperty && groupKey'>\n      <v-card v-for='group in myFilteredGroups' :key='group.name' :class='`mb-3 ${ group.isolated ? \"elevation-15\" : \"elevation-1\"} ${ group.visible ? \"elevation-1\" : \"elevation-0\" }`' v-if='group.objects.length>0'>\n        <v-card-text>\n          <v-layout align-center>\n            <v-flex xs2>\n              <v-avatar size=\"20\" :color=\"getHexFromString(group.name)\"></v-avatar>\n            </v-flex>\n            <v-flex class='caption text-truncate'>\n              <b>{{group.name}}</b>&nbsp;<span class='font-weight-light'>({{group.objects.length}} objects)</span>\n            </v-flex>\n            <v-flex xs4 class='text-xs-right'>\n              <v-btn flat icon small @click.native='toggleVisible(group.name)' :color='group.visible ? \"\":\"grey\"'>\n                <v-icon>remove_red_eye</v-icon>\n              </v-btn>\n              <v-btn flat icon small @click.native='toggleIsolation(group.name)' :color='group.isolated ? \"\":\"grey\"'>\n                <v-icon>location_searching</v-icon>\n              </v-btn>\n            </v-flex>\n          </v-layout>\n        </v-card-text>\n      </v-card>\n    </v-flex>\n    <v-flex xs12 v-if='!isTextProperty && groupKey'>\n      <v-card :class='`mb-3 ${ orphanGroup.isolated ? \"elevation-15\" : \"elevation-1\"} ${ orphanGroup.visible ? \"elevation-1\" : \"elevation-0\" }`' v-if='orphanGroup'>\n        <v-card-text>\n          <v-layout align-center>\n            <v-flex xs1>\n              <!-- <v-avatar size=\"20\" :color=\"getHexFromString(orphanGroup.name)\"></v-avatar> -->\n            </v-flex>\n            <v-flex class='caption'>\n              <b>{{orphanGroup.name}}</b>&nbsp;<span class='font-weight-light'>({{orphanGroup.objects.length}} objects)</span>\n            </v-flex>\n            <v-flex xs4 class='text-xs-right'>\n              <v-btn flat icon small @click.native='toggleVisible(orphanGroup.name)' :color='orphanGroup.visible ? \"\":\"grey\"'>\n                <v-icon>remove_red_eye</v-icon>\n              </v-btn>\n              <v-btn flat icon small @click.native='toggleIsolation(orphanGroup.name)' :color='orphanGroup.isolated ? \"\":\"grey\"'>\n                <v-icon>location_searching</v-icon>\n              </v-btn>\n            </v-flex>\n          </v-layout>\n        </v-card-text>\n      </v-card>\n      <!-- <v-divider></v-divider> -->\n      <v-card class='' v-if='groupKey !== undefined && !isTextProperty && $store.state.legend' xxxv-if=\"$store.state.legend && selectedRange.length !== 0\">\n        <v-card-text v-if='selectedRange'>\n          <h1 class='font-weight-light'>Min: <b>{{selectedRange[0].toLocaleString()}}</b>, Max: <b>{{selectedRange[1].toLocaleString()}}</b></h1>\n        </v-card-text>\n        <v-card-text>\n          <v-layout align-center row wrap>\n            <v-flex xs-12 pa-2 v-if='legend.isNumeric'>\n              <v-range-slider v-model=\"selectedRange\" :max=\"$store.state.legend.max\" :min=\"$store.state.legend.min\" :step=\"0\" @end='filterProp'></v-range-slider>\n            </v-flex>\n            <v-flex xs12 class='caption' v-if='$store.state.legend'>\n              Legend key: <b>{{groupKey}}</b><br> min: <b>{{$store.state.legend.min}}</b>, max: <b>{{$store.state.legend.max}}.</b>\n            </v-flex>\n          </v-layout>\n        </v-card-text>\n      </v-card>\n    </v-flex>\n  </v-layout>\n</template>\n<script>\nimport get from 'lodash.get'\nexport default {\n  name: 'ObjectGroups',\n  props: {\n    groupKeySeed: {\n      type: String,\n      default: null\n    }\n  },\n  watch: {\n    groupKeySeed( newVal, oldVal ) {\n      if ( newVal !== null && this.init === false ) {\n        this.init = true\n        this.groupKey = newVal\n      }\n    },\n    groupKey: {\n      immediate: true,\n      handler( newVal, oldVal ) {\n        if ( newVal === null ) return\n        console.log( \"TEST \" + newVal )\n        this.filterText = ''\n        window.renderer.showObjects( [ ] )\n\n        window.renderer.resetColors( { propagateLegend: true } )\n\n        if ( this.structuralKeys.indexOf( newVal ) !== -1 ) {\n          console.log( 'its a structural propertyyyyyy' )\n          this.generateGroups( 'structural.result.' + newVal )\n          this.appendInfoToUrl( \"groups\", { key: newVal } )\n          window.renderer.colorByVertexArray( { propertyName: newVal, colors: this.rainbowColors } )\n          return\n        }\n\n        if ( newVal ) {\n          this.generateGroups( newVal )\n          this.appendInfoToUrl( \"groups\", { key: newVal } )\n          window.renderer.colorByProperty( { propertyName: newVal, propagateLegend: true, colors: this.coolColors } )\n        }\n\n        if ( newVal === undefined ) {\n          this.appendInfoToUrl( \"groups\", null )\n          window.renderer.showObjects( [ ] )\n        }\n\n      }\n    },\n    legend: {\n      handler: function ( newVal, oldVal ) {\n        if ( !newVal ) return\n        this.min = this.$store.state.legend.min\n        this.max = this.$store.state.legend.max\n        this.selectedRange = [ this.min, this.max ]\n      },\n      deep: true\n    }\n  },\n  computed: {\n    myFilteredGroups( ) {\n      let filteredGroups = {}\n      if ( !this.filterText || this.filterText === '' ) return this.myGroups\n      return this.myGroups.filter( gr => gr.name.toLowerCase( ).includes( this.filterText.toLowerCase( ) ) )\n    },\n    orphanGroup( ) {\n      let orphans = this.myGroups.find( gr => gr.name === \"Orphaned Objects\" )\n      return orphans\n      // return this.myGroups[ 0 ] ? this.myGroups[ 0 ] : null\n    },\n    keys( ) {\n      return this.$store.getters.objectPropertyKeys\n    },\n    allKeys( ) {\n      return [ ...this.$store.getters.objectPropertyKeys.allKeys, ...this.$store.getters.structuralKeys ]\n    },\n    structuralKeys( ) {\n      return this.$store.getters.structuralKeys\n    },\n    isTextProperty( ) {\n      return this.keys.stringKeys.indexOf( this.groupKey ) !== -1\n    },\n    legend( ) {\n      return this.$store.state.legend\n    }\n  },\n  data( ) {\n    return {\n      groupKey: null,\n      myGroups: [ ],\n      loading: false,\n      filterText: null,\n      selectedRange: [ 0, 1000 ],\n      rainbowColors: [ \"#9400D3\", \"#4B0082\", \"#0000FF\", \"#00FF00\", \"#FFFF00\", \"#FF7F00\", \"#FF0000\" ],\n      coolColors: [ \"#0A66FF\", \"#FF008A\" ],\n      init: false\n    }\n  },\n  methods: {\n    generateGroups( key ) {\n      this.myGroups = [ ]\n      this.loading = true\n\n      let groups = { orphans: { key: 'orphans', name: 'Orphaned Objects', objects: [ ], visible: true, isolated: false } }\n\n      if ( this.isTextProperty ) {\n\n        this.$store.state.objects.forEach( ( obj, index ) => {\n          let propValue = get( obj.properties, key )\n          if ( propValue ) {\n            // if we have the group already\n            if ( groups.hasOwnProperty( propValue ) ) {\n              groups[ propValue ].objects.push( obj._id )\n            } else {\n              groups[ propValue ] = {\n                key: key,\n                name: propValue,\n                objects: [ obj._id ],\n                visible: true,\n                isolated: false\n              }\n            }\n          } else {\n            groups.orphans.objects.push( obj._id )\n          }\n          if ( index === this.$store.state.objects.length - 1 ) {\n            this.loading = false\n          }\n        } )\n\n      }\n      Object.keys( groups ).forEach( key => this.myGroups.push( groups[ key ] ) )\n    },\n    filterProp( ) {\n      let objIds = [ ]\n\n      this.$store.state.objects.forEach( ( obj, index ) => {\n        let propValue = get( obj.properties, this.groupKey )\n        if ( propValue )\n          if ( propValue >= this.selectedRange[ 0 ] && propValue <= this.selectedRange[ 1 ] )\n            objIds.push( obj._id )\n\n\n        if ( index === this.$store.state.objects.length - 1 ) {\n          if ( this.myGroups[ 0 ] && this.myGroups[ 0 ].visible )\n            objIds = [ ...objIds, ...this.myGroups[ 0 ].objects ]\n\n          window.renderer.isolateObjects( objIds )\n          window.renderer.resetColors( { propagateLegend: false } )\n          window.renderer.colorByProperty( { propertyName: this.groupKey, propagateLegend: false, colors: this.coolColors } )\n        }\n      } )\n    },\n    toggleVisible( groupName ) {\n      let group = this.myGroups.find( gr => gr.name === groupName )\n      if ( group.visible ) {\n        window.renderer.hideObjects( group.objects )\n        group.visible = false\n      } else {\n        window.renderer.showObjects( group.objects )\n        group.visible = true\n      }\n    },\n    toggleIsolation( groupName ) {\n      let group = this.myGroups.find( gr => gr.name === groupName )\n      if ( group.isolated ) {\n        window.renderer.showObjects( [ ] )\n        group.isolated = false\n      } else {\n        group.visible = true\n        group.isolated = true\n        window.renderer.isolateObjects( group.objects )\n      }\n\n      this.myGroups.forEach( gr => {\n        if ( gr.name === groupName ) return\n        if ( group.isolated ) {\n          gr.isolated = false\n          gr.visible = false\n        } else {\n          gr.visible = true\n          window.renderer.showObjects( gr.objects )\n        }\n      } )\n    },\n\n  },\n  mounted( ) {\n    // console.log( 'mounted - object groups' )\n    // console.log( this.groupKeySeed )\n    // if ( this.groupKeySeed !== null ) {\n    //   this.groupKey = this.groupKeySeed\n    // }\n  },\n  activated( ) {\n    if ( this.groupKey ) {\n      this.appendInfoToUrl( \"groups\", { key: this.groupKey } )\n    }\n  }\n}\n\n</script>\n<style scoped lang='scss'>\n</style>\n"]}]}