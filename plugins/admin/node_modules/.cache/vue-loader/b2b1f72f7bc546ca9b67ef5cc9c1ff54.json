{"remainingRequest":"/Users/donnykurnia/data/Projects/upwork/3dbyggeri/glasshouse/SpeckleServer/plugins/admin/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/donnykurnia/data/Projects/upwork/3dbyggeri/glasshouse/SpeckleServer/plugins/admin/src/views/Viewer.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/donnykurnia/data/Projects/upwork/3dbyggeri/glasshouse/SpeckleServer/plugins/admin/src/views/Viewer.vue","mtime":1609071089437},{"path":"/Users/donnykurnia/data/Projects/upwork/3dbyggeri/glasshouse/SpeckleServer/plugins/admin/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/donnykurnia/data/Projects/upwork/3dbyggeri/glasshouse/SpeckleServer/plugins/admin/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/donnykurnia/data/Projects/upwork/3dbyggeri/glasshouse/SpeckleServer/plugins/admin/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport debounce from 'lodash.debounce'\n\nimport StreamCard from '@/components/ViewerLoadedStreamsCard.vue'\nimport StreamSearch from '@/components/StreamSearch.vue'\nimport ObjectGroups from '@/components/ViewerObjectGroups.vue'\nimport SelectedObjects from '@/components/ViewerSelectedObjects.vue'\nimport Settings from '@/components/ViewerSettings.vue'\n\nimport SpeckleRenderer from '@/renderer/SpeckleRenderer.js'\n\nexport default {\n  name: 'ViewerView',\n  components: { StreamSearch, StreamCard, ObjectGroups, SelectedObjects, Settings },\n  computed: {\n    loadedStreamIds( ) {\n      return this.$store.state.loadedStreamIds\n    },\n    loadedStreams( ) {\n      return this.$store.state.streams.filter( str => this.loadedStreamIds.indexOf( str.streamId ) !== -1 )\n    },\n    streams( ) {\n      return this.$store.state.streams.filter( s => this.streamIds.indexOf( s.streamId ) !== -1 )\n    },\n    streamIds( ) {\n      return this.$store.state.loadedStreamIds\n    },\n  },\n  data( ) {\n    return {\n      customStreamId: null,\n      showStreamIdDialog: false,\n      customDialogErr: false,\n      showLoading: false,\n      looadingProgress: 0,\n      loadingIsDeterminate: false,\n      toRequest: [ ],\n      requestBuckets: [ ],\n      isRequesting: false,\n      pauseRequesting: false,\n      bucketInProgress: false,\n      removeInterval: null,\n      streamsToRemove: [ ],\n      selectedFilter: null,\n      showTheThing: true,\n      cameraPos: null,\n      cameraPosToSet: null,\n      groupKeyToSet: null,\n      activeTab: 0\n    }\n  },\n  watch: {\n    showLoading( newVal, oldVal ) {\n      console.log( `showLoading is now ${newVal}` )\n      if ( this.cameraPosToSet === null && this.groupKeyToSet === null ) return\n\n      if ( newVal === false ) {\n        if ( this.cameraPosToSet ) {\n\n          this.renderer.computeSceneBoundingSphere( )\n          this.renderer.setFar( )\n\n          this.renderer.setCamera( { ...this.cameraPosToSet }, 1600 )\n          this.cameraPosToSet = null\n        }\n        if ( this.groupKeyToSet ) {\n          this.selectedFilter = this.groupKeyToSet\n          this.groupKeyToSet = null\n          this.activeTab = 1\n        }\n      }\n    }\n  },\n  methods: {\n    appendStreamsToRoute( streamId ) {\n      // NOTE: this functionality is disabled because o\n      let streams = this.$store.state.loadedStreamIds.join( ',' )\n      if ( streams !== '' )\n        this.$router.replace( { name: 'viewer', params: { streamIds: streams }, query: { ...this.$route.query } } )\n      else this.$router.replace( { name: 'viewer', query: { ...this.$route.query } } )\n    },\n    async directAddStream( ) {\n      try {\n        await this.$store.dispatch( 'getStream', { streamId: this.customStreamId } )\n        this.addStream( this.customStreamId )\n        this.customStreamId = null\n        this.showStreamIdDialog = false\n      } catch ( err ) {\n        this.customStreamId = null\n        this.customDialogErr = true\n        // this.showStreamIdDialog = false\n      }\n    },\n    async addStream( streamId ) {\n      this.showLoading = true\n      this.$store.commit( 'ADD_LOADED_STREAMID', streamId )\n      this.appendStreamsToRoute( )\n      try {\n        let objectIds = await this.$store.dispatch( 'getStreamObjects', streamId )\n\n        if ( objectIds.length === 0 ) {\n          this.showLoading = false\n          return\n        }\n\n        // loaded already?\n        let toRequest = objectIds.filter( id => this.$store.state.objects.findIndex( o => o._id === id ) === -1 )\n        let toUpdate = objectIds.filter( id => this.$store.state.objects.findIndex( o => o._id === id ) !== -1 )\n        this.$store.commit( 'UPDATE_OBJECTS_STREAMS', { objIds: toUpdate, streamToAdd: streamId } )\n\n        let bucket = [ ],\n          maxReq = 50 // magic number; maximum objects to request in a bucket\n\n        for ( let i = 0; i < toRequest.length; i++ ) {\n          bucket.push( toRequest[ i ] )\n          if ( i % maxReq === 0 && i !== 0 ) {\n            this.requestBuckets.push( { objectIds: [ ...bucket ], streamId: streamId } )\n            bucket = [ ]\n            if ( !this.isRequesting ) this.bucketProcessor( )\n          }\n        }\n\n        // last one\n        if ( bucket.length !== 0 ) {\n          this.requestBuckets.push( { objectIds: [ ...bucket ], streamId: streamId } )\n          if ( !this.isRequesting ) this.bucketProcessor( )\n        }\n      } catch ( err ) {\n        this.showLoading = false\n      }\n    },\n    // Goes through all the request buckets and requests them from the server,\n    // then plops them in the renderer as they go\n    async bucketProcessor( ) {\n      if ( this.pauseRequesting ) return\n      if ( this.requestBuckets.length === 0 ) {\n        this.isRequesting = false\n        // as we don't want to flood the vue store with a lotta add objects calls,\n        // we store all objects in an accumulator and commit that once we're done\n        if ( this.objectAccumulator.length > 0 )\n          this.$store.commit( 'ADD_OBJECTS', this.objectAccumulator )\n        this.objectAccumulator = [ ]\n        console.log( `done processing buckets!` )\n        this.showLoading = false\n\n        if ( this.cameraPosToSet === null )\n          this.renderer.zoomExtents( )\n\n        bus.$emit( 'loading-done' )\n        return\n      }\n\n      this.isRequesting = true\n      this.bucketInProgress = true\n\n      let objs = await this.$store.dispatch( 'getObjects', this.requestBuckets[ 0 ].objectIds )\n      let stream = this.$store.state.streams.find( s => s.streamId === this.requestBuckets[ 0 ].streamId )\n\n      objs.forEach( ( o, index ) => {\n        if ( !o.properties ) o.properties = {}\n        o.properties.id = o._id ? o._id : 'no id'\n        o.properties.hash = o.hash ? o.hash : 'no hash'\n        o.properties.speckle_type = o.type\n        let objIndexInStream = stream.objects.indexOf( o._id )\n        o.properties.objIndexInStream = objIndexInStream\n\n        let layer = null\n        for ( let ll of stream.layers ) {\n          if ( objIndexInStream >= ll.startIndex )\n            if ( objIndexInStream < ll.startIndex + ll.objectCount )\n              layer = ll\n        }\n\n        o.streams = [ this.requestBuckets[ 0 ].streamId ]\n\n        if ( layer && layer.properties ) {\n          o.color = { hex: '#909090', a: 0.65 }\n          o.properties.layer_guid = layer.guid ? layer.guid : 'no layer guid'\n          o.properties.layer_name = layer.name\n        } else if ( layer ) {\n          o.properties.layer_guid = layer.guid\n          o.properties.layer_name = layer.name\n          o.color = { hex: '#909090', a: 0.65 }\n        } else {\n          o.properties.layer_name = 'no layer'\n          o.color = { hex: '#909090', a: 0.65 }\n        }\n\n      } )\n\n      this.objectAccumulator.push( ...objs.map( obj => { return Object.freeze( { type: obj.type, properties: obj.properties ? obj.properties : null, streams: obj.streams, _id: obj._id, hash: obj.hash } ) } ) )\n      // No freezing as we're modifying the props; mem footprint seems ok still\n      // this.objectAccumulator.push( ...objs.map( obj => { return { type: obj.type, properties: obj.properties ? obj.properties : null, streams: obj.streams, _id: obj._id, hash: obj.hash } } ) )\n\n      // this.renderer.loadObjects( { objs: objs, zoomExtents: this.requestBuckets.length === 1 } )\n      this.renderer.loadObjects( { objs: objs, zoomExtents: false } )\n      this.requestBuckets.splice( 0, 1 )\n\n      this.bucketInProgress = false\n      this.bucketProcessor( )\n    },\n\n    // pauses and any bucket loading and waits for it to stop,\n    // then triggers the real remove stream\n    async removeStream( streamId ) {\n      this.pauseRequesting = true\n      if ( this.streamsToRemove.indexOf( streamId ) === -1 )\n        this.streamsToRemove.push( streamId )\n      this.removeInterval = setInterval( this.removeStreamInternal.bind( this ), 250 )\n    },\n\n    // removes any objects pertaining to one stream, even half loaded ones\n    // works with a temporary state. Restarts the bucket processor\n    // in case there were other buckets queued from other stream loads.\n    removeStreamInternal( ) {\n      if ( this.bucketInProgress ) return\n      clearInterval( this.removeInterval )\n      // create a list of all objects, including ones that are possibly still \"accumulating\"\n      let tempState = [ ...this.$store.state.objects, ...this.objectAccumulator ]\n\n      // clean future loading buckets, if any are present\n      this.requestBuckets = this.requestBuckets.filter( b => this.streamsToRemove.indexOf( b.streamId ) === -1 )\n\n      let objIdsToUnload = [ ]\n      this.streams.forEach( s => this.streamsToRemove.indexOf( s.streamId ) !== -1 ? objIdsToUnload.push( ...s.objects ) : null )\n\n      this.streamsToRemove.forEach( stream => this.$store.commit( 'UPDATE_OBJECTS_STREAMS', { objIds: objIdsToUnload, streamToRemove: stream } ) )\n\n      // filter out objects that are in another stream.\n      objIdsToUnload = objIdsToUnload.filter( id => {\n        let x = tempState.find( o => o._id === id )\n        if ( x ) return x.streams.length === 0\n        return false // means the object was not loaded yet\n      } )\n\n      this.streamsToRemove.forEach( sId => {\n        this.$store.commit( 'REMOVE_LOADED_STREAMID', sId )\n      } )\n\n      this.$store.commit( 'REMOVE_OBJECTS', objIdsToUnload )\n\n      this.renderer.unloadObjects( { objIds: objIdsToUnload } )\n      this.pauseRequesting = false\n      this.streamsToRemove = [ ]\n      this.appendStreamsToRoute( )\n      // restart the bucket processor\n      this.bucketProcessor( )\n    },\n\n    setBucketsAndGo( buckets ) {\n      // this.showLoading = true\n      this.requestBuckets = buckets\n      this.bucketProcessor( )\n    },\n\n    async refreshStream( streamId ) {\n      this.showLoading = true\n\n      let oldObjectIds = this.$store.state.objects.filter( obj => obj.streams.indexOf( streamId ) !== -1 ).map( obj => obj._id )\n      let currObjectIds = await this.$store.dispatch( 'getStreamObjects', streamId )\n\n      let toAdd = currObjectIds.filter( id => oldObjectIds.indexOf( id ) === -1 )\n      let toRem = oldObjectIds.filter( id => currObjectIds.indexOf( id ) === -1 )\n\n      this.$store.commit( 'UPDATE_OBJECTS_STREAMS', { objIds: toRem, streamToRemove: streamId } )\n\n      let toDelete = this.$store.state.objects.filter( obj => obj.streams.length === 0 ).map( o => o._id )\n      this.renderer.unloadObjects( { objIds: toDelete } )\n      this.$store.commit( 'REMOVE_OBJECTS', toDelete )\n\n      // objects that i need to request for sure, as they have not been loaded before.\n      let toRequest = toAdd.filter( id => this.$store.state.objects.findIndex( o => o._id === id ) === -1 )\n\n      if ( toRequest.length === 0 ) {\n        this.showLoading = false\n        return\n      }\n\n      let bucket = [ ],\n        maxReq = 50 // magic number; maximum objects to request in a bucket\n\n      for ( let i = 0; i < toRequest.length; i++ ) {\n        bucket.push( toRequest[ i ] )\n        if ( i % maxReq === 0 && i !== 0 ) {\n          this.requestBuckets.push( { objectIds: [ ...bucket ], streamId: streamId } )\n          bucket = [ ]\n          if ( !this.isRequesting ) this.bucketProcessor( )\n        }\n      }\n\n      // last one\n      if ( bucket.length !== 0 ) {\n        this.requestBuckets.push( { objectIds: [ ...bucket ], streamId: streamId } )\n        if ( !this.isRequesting ) this.bucketProcessor( )\n      }\n    },\n\n    fetchStreamsFromRoute( ) {\n      if ( this.$route.params.streamIds ) {\n        let urlStreams = this.$route.params.streamIds.split( ',' )\n        let streamsToLoad = urlStreams.filter( id => this.$store.state.loadedStreamIds.indexOf( id ) === -1 )\n        let streamsToUnload = this.$store.state.loadedStreamIds.filter( id => urlStreams.indexOf( id ) === -1 )\n        streamsToUnload.forEach( sid => this.removeStream( sid ) )\n        streamsToLoad.forEach( sid => this.addStream( sid ) )\n      }\n    },\n\n    updateViewerSettings( ) {\n      this.renderer.viewerSettings = this.$store.state.viewer\n      this.renderer.updateViewerSettings( )\n    }\n  },\n  activated( ) {\n    console.log( 'activated' )\n    document.body.classList.add( 'no-scroll' )\n\n    this.fetchStreamsFromRoute( )\n    this.appendStreamsToRoute( )\n\n  },\n  deactivated( ) {\n    console.log( 'de-activated' )\n    document.body.classList.remove( 'no-scroll' )\n  },\n  mounted( ) {\n    console.log( 'mounted' )\n    this.objectAccumulator = [ ]\n\n    let settingsString = localStorage.getItem( 'viewerSettings' )\n    let viewerSettings = JSON.parse( settingsString )\n    if ( null != viewerSettings ) this.$store.commit( 'SET_ALL_VIEWER_SETTINGS', viewerSettings )\n\n    this.renderer = new SpeckleRenderer( { domObject: this.$refs.render }, this.$store.state.viewer )\n    this.renderer.animate( )\n\n    // if you like polluting the global scope, clap twice\n    window.renderer = this.renderer\n\n    // add streams to viewer\n    this.fetchStreamsFromRoute( )\n\n    let queryObject = this.getUrlQueryObject( )\n\n    // query init events (mounted, not activated!)\n    if ( queryObject.camera ) this.cameraPosToSet = queryObject.camera\n    if ( queryObject.groups ) this.groupKeyToSet = queryObject.groups.key\n\n    setTimeout( ( ) => {\n      this.$store.commit( 'SET_VIEWER_CONTROLS', true )\n    }, 100 )\n\n    // Set render events\n    this.renderer.on( 'select-objects', debounce( function ( ids ) {\n      this.$store.commit( 'SET_SELECTED_OBJECTS', { objectIds: ids } )\n    }.bind( this ), 250 ) )\n\n    this.renderer.on( 'select-add-objects', debounce( function ( ids ) {\n      this.$store.commit( 'ADD_SELECTED_OBJECTS', { objectIds: ids } )\n    }.bind( this ), 250 ) )\n\n    this.renderer.on( 'select-remove-objects', debounce( function ( ids ) {\n      this.$store.commit( 'REMOVE_SELECTED_OBJECTS', { objectIds: ids } )\n    }.bind( this ), 250 ) )\n\n    this.renderer.on( 'analysis-legend', legend => {\n      this.$store.commit( 'SET_LEGEND', legend )\n    } )\n\n    this.renderer.on( 'clear-analysis-legend', ( ) => {\n      this.$store.commit( 'SET_LEGEND', null )\n    } )\n\n    this.renderer.on( 'camera-pos', cam => {\n      this.appendInfoToUrl( \"camera\", cam )\n    } )\n  }\n}\n\n",{"version":3,"sources":["Viewer.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqFA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"Viewer.vue","sourceRoot":"src/views","sourcesContent":["<template>\n  <v-container fluid fill-height pa-0 xxxstyle='height: calc(100vh - 64px);'>\n    <div style='position: absolute; top:0; width: 100%; z-index: 1000;'>\n      <v-progress-linear :indeterminate=\"true\" v-show='showLoading' height='2' class='ma-0'></v-progress-linear>\n    </div>\n    <div class='renderer' ref='render'></div>\n    <v-navigation-drawer v-model=\"$store.state.viewerControls\" right app clipped stateless style='z-index: 2' width='400' fixed hide-overlay>\n      <v-layout row wrap style=\"height: auto;\">\n        <!-- <v-flex xs12 style='height:60px;' class='hidden-xs-and-up hidden-md-and-up'>&nbsp;</v-flex> -->\n        <v-flex xs12>\n          <v-tabs grow slider-color='primary' color='rgba(0,0,0,0)' v-model='activeTab'>\n            <v-tab key='streams'>\n              <v-icon>import_export</v-icon>\n            </v-tab>\n            <v-tab key='filter'>\n              <v-icon>layers</v-icon>\n            </v-tab>\n            <v-tab key='inspector'>\n              <v-badge small right :value='$store.state.selectedObjects.length>0' color='primary'>\n                <template v-slot:badge>\n                  <span>{{$store.state.selectedObjects.length}}</span>\n                </template>\n                <v-icon>\n                  code\n                </v-icon>\n              </v-badge>\n            </v-tab>\n            <v-tab key='settings'>\n              <v-icon>settings</v-icon>\n            </v-tab>\n            <v-tab-item key='streams'>\n              <v-card class='elevation-0 transparent'>\n                <v-card-text>\n                  <stream-search v-on:selected-stream='addStream' :streams-to-omit='loadedStreamIds'></stream-search>\n                  <p class='caption mt-0 pb-2'>\n                    or add by<a @click='showStreamIdDialog=true'> streamId</a>\n                  </p>\n                  <v-dialog v-model=\"showStreamIdDialog\" width=\"500\">\n                    <v-card>\n                      <v-form @submit.prevent='directAddStream'>\n                        <v-card-text>\n                          <v-text-field style='width: 100%' v-model='customStreamId' name='custom stream id' label='custom stream id'></v-text-field>\n                        </v-card-text>\n                        <v-card-actions>\n                          <v-spacer></v-spacer>\n                          <v-btn submit @click='directAddStream'>ADD</v-btn>\n                        </v-card-actions>\n                        <v-alert v-model='customDialogErr' dismissible>\n                          Failed to find stream with that id.\n                        </v-alert>\n                      </v-form>\n                    </v-card>\n                  </v-dialog>\n                  <stream-card v-for='stream in loadedStreams' :stream='stream' :key='stream.streamId' @remove='removeStream' @refresh='refreshStream'></stream-card>\n                </v-card-text>\n              </v-card>\n            </v-tab-item>\n            <v-tab-item key='filter'>\n              <v-card class='elevation-0 transparent'>\n                <v-card-text>\n                  <object-groups :group-key-seed='selectedFilter'></object-groups>\n                </v-card-text>\n              </v-card>\n            </v-tab-item>\n            <v-tab-item key='inspector'>\n              <v-card class='elevation-0 transparent'>\n                <v-card-text>\n                  <selected-objects></selected-objects>\n                </v-card-text>\n              </v-card>\n            </v-tab-item>\n            <v-tab-item key='settings'>\n              <v-card class='elevation-0 transparent'>\n                <v-card-text>\n                  <settings @update='updateViewerSettings' />\n                </v-card-text>\n              </v-card>\n            </v-tab-item>\n          </v-tabs>\n        </v-flex>\n      </v-layout>\n    </v-navigation-drawer>\n  </v-container>\n</template>\n<script>\nimport debounce from 'lodash.debounce'\n\nimport StreamCard from '@/components/ViewerLoadedStreamsCard.vue'\nimport StreamSearch from '@/components/StreamSearch.vue'\nimport ObjectGroups from '@/components/ViewerObjectGroups.vue'\nimport SelectedObjects from '@/components/ViewerSelectedObjects.vue'\nimport Settings from '@/components/ViewerSettings.vue'\n\nimport SpeckleRenderer from '@/renderer/SpeckleRenderer.js'\n\nexport default {\n  name: 'ViewerView',\n  components: { StreamSearch, StreamCard, ObjectGroups, SelectedObjects, Settings },\n  computed: {\n    loadedStreamIds( ) {\n      return this.$store.state.loadedStreamIds\n    },\n    loadedStreams( ) {\n      return this.$store.state.streams.filter( str => this.loadedStreamIds.indexOf( str.streamId ) !== -1 )\n    },\n    streams( ) {\n      return this.$store.state.streams.filter( s => this.streamIds.indexOf( s.streamId ) !== -1 )\n    },\n    streamIds( ) {\n      return this.$store.state.loadedStreamIds\n    },\n  },\n  data( ) {\n    return {\n      customStreamId: null,\n      showStreamIdDialog: false,\n      customDialogErr: false,\n      showLoading: false,\n      looadingProgress: 0,\n      loadingIsDeterminate: false,\n      toRequest: [ ],\n      requestBuckets: [ ],\n      isRequesting: false,\n      pauseRequesting: false,\n      bucketInProgress: false,\n      removeInterval: null,\n      streamsToRemove: [ ],\n      selectedFilter: null,\n      showTheThing: true,\n      cameraPos: null,\n      cameraPosToSet: null,\n      groupKeyToSet: null,\n      activeTab: 0\n    }\n  },\n  watch: {\n    showLoading( newVal, oldVal ) {\n      console.log( `showLoading is now ${newVal}` )\n      if ( this.cameraPosToSet === null && this.groupKeyToSet === null ) return\n\n      if ( newVal === false ) {\n        if ( this.cameraPosToSet ) {\n\n          this.renderer.computeSceneBoundingSphere( )\n          this.renderer.setFar( )\n\n          this.renderer.setCamera( { ...this.cameraPosToSet }, 1600 )\n          this.cameraPosToSet = null\n        }\n        if ( this.groupKeyToSet ) {\n          this.selectedFilter = this.groupKeyToSet\n          this.groupKeyToSet = null\n          this.activeTab = 1\n        }\n      }\n    }\n  },\n  methods: {\n    appendStreamsToRoute( streamId ) {\n      // NOTE: this functionality is disabled because o\n      let streams = this.$store.state.loadedStreamIds.join( ',' )\n      if ( streams !== '' )\n        this.$router.replace( { name: 'viewer', params: { streamIds: streams }, query: { ...this.$route.query } } )\n      else this.$router.replace( { name: 'viewer', query: { ...this.$route.query } } )\n    },\n    async directAddStream( ) {\n      try {\n        await this.$store.dispatch( 'getStream', { streamId: this.customStreamId } )\n        this.addStream( this.customStreamId )\n        this.customStreamId = null\n        this.showStreamIdDialog = false\n      } catch ( err ) {\n        this.customStreamId = null\n        this.customDialogErr = true\n        // this.showStreamIdDialog = false\n      }\n    },\n    async addStream( streamId ) {\n      this.showLoading = true\n      this.$store.commit( 'ADD_LOADED_STREAMID', streamId )\n      this.appendStreamsToRoute( )\n      try {\n        let objectIds = await this.$store.dispatch( 'getStreamObjects', streamId )\n\n        if ( objectIds.length === 0 ) {\n          this.showLoading = false\n          return\n        }\n\n        // loaded already?\n        let toRequest = objectIds.filter( id => this.$store.state.objects.findIndex( o => o._id === id ) === -1 )\n        let toUpdate = objectIds.filter( id => this.$store.state.objects.findIndex( o => o._id === id ) !== -1 )\n        this.$store.commit( 'UPDATE_OBJECTS_STREAMS', { objIds: toUpdate, streamToAdd: streamId } )\n\n        let bucket = [ ],\n          maxReq = 50 // magic number; maximum objects to request in a bucket\n\n        for ( let i = 0; i < toRequest.length; i++ ) {\n          bucket.push( toRequest[ i ] )\n          if ( i % maxReq === 0 && i !== 0 ) {\n            this.requestBuckets.push( { objectIds: [ ...bucket ], streamId: streamId } )\n            bucket = [ ]\n            if ( !this.isRequesting ) this.bucketProcessor( )\n          }\n        }\n\n        // last one\n        if ( bucket.length !== 0 ) {\n          this.requestBuckets.push( { objectIds: [ ...bucket ], streamId: streamId } )\n          if ( !this.isRequesting ) this.bucketProcessor( )\n        }\n      } catch ( err ) {\n        this.showLoading = false\n      }\n    },\n    // Goes through all the request buckets and requests them from the server,\n    // then plops them in the renderer as they go\n    async bucketProcessor( ) {\n      if ( this.pauseRequesting ) return\n      if ( this.requestBuckets.length === 0 ) {\n        this.isRequesting = false\n        // as we don't want to flood the vue store with a lotta add objects calls,\n        // we store all objects in an accumulator and commit that once we're done\n        if ( this.objectAccumulator.length > 0 )\n          this.$store.commit( 'ADD_OBJECTS', this.objectAccumulator )\n        this.objectAccumulator = [ ]\n        console.log( `done processing buckets!` )\n        this.showLoading = false\n\n        if ( this.cameraPosToSet === null )\n          this.renderer.zoomExtents( )\n\n        bus.$emit( 'loading-done' )\n        return\n      }\n\n      this.isRequesting = true\n      this.bucketInProgress = true\n\n      let objs = await this.$store.dispatch( 'getObjects', this.requestBuckets[ 0 ].objectIds )\n      let stream = this.$store.state.streams.find( s => s.streamId === this.requestBuckets[ 0 ].streamId )\n\n      objs.forEach( ( o, index ) => {\n        if ( !o.properties ) o.properties = {}\n        o.properties.id = o._id ? o._id : 'no id'\n        o.properties.hash = o.hash ? o.hash : 'no hash'\n        o.properties.speckle_type = o.type\n        let objIndexInStream = stream.objects.indexOf( o._id )\n        o.properties.objIndexInStream = objIndexInStream\n\n        let layer = null\n        for ( let ll of stream.layers ) {\n          if ( objIndexInStream >= ll.startIndex )\n            if ( objIndexInStream < ll.startIndex + ll.objectCount )\n              layer = ll\n        }\n\n        o.streams = [ this.requestBuckets[ 0 ].streamId ]\n\n        if ( layer && layer.properties ) {\n          o.color = { hex: '#909090', a: 0.65 }\n          o.properties.layer_guid = layer.guid ? layer.guid : 'no layer guid'\n          o.properties.layer_name = layer.name\n        } else if ( layer ) {\n          o.properties.layer_guid = layer.guid\n          o.properties.layer_name = layer.name\n          o.color = { hex: '#909090', a: 0.65 }\n        } else {\n          o.properties.layer_name = 'no layer'\n          o.color = { hex: '#909090', a: 0.65 }\n        }\n\n      } )\n\n      this.objectAccumulator.push( ...objs.map( obj => { return Object.freeze( { type: obj.type, properties: obj.properties ? obj.properties : null, streams: obj.streams, _id: obj._id, hash: obj.hash } ) } ) )\n      // No freezing as we're modifying the props; mem footprint seems ok still\n      // this.objectAccumulator.push( ...objs.map( obj => { return { type: obj.type, properties: obj.properties ? obj.properties : null, streams: obj.streams, _id: obj._id, hash: obj.hash } } ) )\n\n      // this.renderer.loadObjects( { objs: objs, zoomExtents: this.requestBuckets.length === 1 } )\n      this.renderer.loadObjects( { objs: objs, zoomExtents: false } )\n      this.requestBuckets.splice( 0, 1 )\n\n      this.bucketInProgress = false\n      this.bucketProcessor( )\n    },\n\n    // pauses and any bucket loading and waits for it to stop,\n    // then triggers the real remove stream\n    async removeStream( streamId ) {\n      this.pauseRequesting = true\n      if ( this.streamsToRemove.indexOf( streamId ) === -1 )\n        this.streamsToRemove.push( streamId )\n      this.removeInterval = setInterval( this.removeStreamInternal.bind( this ), 250 )\n    },\n\n    // removes any objects pertaining to one stream, even half loaded ones\n    // works with a temporary state. Restarts the bucket processor\n    // in case there were other buckets queued from other stream loads.\n    removeStreamInternal( ) {\n      if ( this.bucketInProgress ) return\n      clearInterval( this.removeInterval )\n      // create a list of all objects, including ones that are possibly still \"accumulating\"\n      let tempState = [ ...this.$store.state.objects, ...this.objectAccumulator ]\n\n      // clean future loading buckets, if any are present\n      this.requestBuckets = this.requestBuckets.filter( b => this.streamsToRemove.indexOf( b.streamId ) === -1 )\n\n      let objIdsToUnload = [ ]\n      this.streams.forEach( s => this.streamsToRemove.indexOf( s.streamId ) !== -1 ? objIdsToUnload.push( ...s.objects ) : null )\n\n      this.streamsToRemove.forEach( stream => this.$store.commit( 'UPDATE_OBJECTS_STREAMS', { objIds: objIdsToUnload, streamToRemove: stream } ) )\n\n      // filter out objects that are in another stream.\n      objIdsToUnload = objIdsToUnload.filter( id => {\n        let x = tempState.find( o => o._id === id )\n        if ( x ) return x.streams.length === 0\n        return false // means the object was not loaded yet\n      } )\n\n      this.streamsToRemove.forEach( sId => {\n        this.$store.commit( 'REMOVE_LOADED_STREAMID', sId )\n      } )\n\n      this.$store.commit( 'REMOVE_OBJECTS', objIdsToUnload )\n\n      this.renderer.unloadObjects( { objIds: objIdsToUnload } )\n      this.pauseRequesting = false\n      this.streamsToRemove = [ ]\n      this.appendStreamsToRoute( )\n      // restart the bucket processor\n      this.bucketProcessor( )\n    },\n\n    setBucketsAndGo( buckets ) {\n      // this.showLoading = true\n      this.requestBuckets = buckets\n      this.bucketProcessor( )\n    },\n\n    async refreshStream( streamId ) {\n      this.showLoading = true\n\n      let oldObjectIds = this.$store.state.objects.filter( obj => obj.streams.indexOf( streamId ) !== -1 ).map( obj => obj._id )\n      let currObjectIds = await this.$store.dispatch( 'getStreamObjects', streamId )\n\n      let toAdd = currObjectIds.filter( id => oldObjectIds.indexOf( id ) === -1 )\n      let toRem = oldObjectIds.filter( id => currObjectIds.indexOf( id ) === -1 )\n\n      this.$store.commit( 'UPDATE_OBJECTS_STREAMS', { objIds: toRem, streamToRemove: streamId } )\n\n      let toDelete = this.$store.state.objects.filter( obj => obj.streams.length === 0 ).map( o => o._id )\n      this.renderer.unloadObjects( { objIds: toDelete } )\n      this.$store.commit( 'REMOVE_OBJECTS', toDelete )\n\n      // objects that i need to request for sure, as they have not been loaded before.\n      let toRequest = toAdd.filter( id => this.$store.state.objects.findIndex( o => o._id === id ) === -1 )\n\n      if ( toRequest.length === 0 ) {\n        this.showLoading = false\n        return\n      }\n\n      let bucket = [ ],\n        maxReq = 50 // magic number; maximum objects to request in a bucket\n\n      for ( let i = 0; i < toRequest.length; i++ ) {\n        bucket.push( toRequest[ i ] )\n        if ( i % maxReq === 0 && i !== 0 ) {\n          this.requestBuckets.push( { objectIds: [ ...bucket ], streamId: streamId } )\n          bucket = [ ]\n          if ( !this.isRequesting ) this.bucketProcessor( )\n        }\n      }\n\n      // last one\n      if ( bucket.length !== 0 ) {\n        this.requestBuckets.push( { objectIds: [ ...bucket ], streamId: streamId } )\n        if ( !this.isRequesting ) this.bucketProcessor( )\n      }\n    },\n\n    fetchStreamsFromRoute( ) {\n      if ( this.$route.params.streamIds ) {\n        let urlStreams = this.$route.params.streamIds.split( ',' )\n        let streamsToLoad = urlStreams.filter( id => this.$store.state.loadedStreamIds.indexOf( id ) === -1 )\n        let streamsToUnload = this.$store.state.loadedStreamIds.filter( id => urlStreams.indexOf( id ) === -1 )\n        streamsToUnload.forEach( sid => this.removeStream( sid ) )\n        streamsToLoad.forEach( sid => this.addStream( sid ) )\n      }\n    },\n\n    updateViewerSettings( ) {\n      this.renderer.viewerSettings = this.$store.state.viewer\n      this.renderer.updateViewerSettings( )\n    }\n  },\n  activated( ) {\n    console.log( 'activated' )\n    document.body.classList.add( 'no-scroll' )\n\n    this.fetchStreamsFromRoute( )\n    this.appendStreamsToRoute( )\n\n  },\n  deactivated( ) {\n    console.log( 'de-activated' )\n    document.body.classList.remove( 'no-scroll' )\n  },\n  mounted( ) {\n    console.log( 'mounted' )\n    this.objectAccumulator = [ ]\n\n    let settingsString = localStorage.getItem( 'viewerSettings' )\n    let viewerSettings = JSON.parse( settingsString )\n    if ( null != viewerSettings ) this.$store.commit( 'SET_ALL_VIEWER_SETTINGS', viewerSettings )\n\n    this.renderer = new SpeckleRenderer( { domObject: this.$refs.render }, this.$store.state.viewer )\n    this.renderer.animate( )\n\n    // if you like polluting the global scope, clap twice\n    window.renderer = this.renderer\n\n    // add streams to viewer\n    this.fetchStreamsFromRoute( )\n\n    let queryObject = this.getUrlQueryObject( )\n\n    // query init events (mounted, not activated!)\n    if ( queryObject.camera ) this.cameraPosToSet = queryObject.camera\n    if ( queryObject.groups ) this.groupKeyToSet = queryObject.groups.key\n\n    setTimeout( ( ) => {\n      this.$store.commit( 'SET_VIEWER_CONTROLS', true )\n    }, 100 )\n\n    // Set render events\n    this.renderer.on( 'select-objects', debounce( function ( ids ) {\n      this.$store.commit( 'SET_SELECTED_OBJECTS', { objectIds: ids } )\n    }.bind( this ), 250 ) )\n\n    this.renderer.on( 'select-add-objects', debounce( function ( ids ) {\n      this.$store.commit( 'ADD_SELECTED_OBJECTS', { objectIds: ids } )\n    }.bind( this ), 250 ) )\n\n    this.renderer.on( 'select-remove-objects', debounce( function ( ids ) {\n      this.$store.commit( 'REMOVE_SELECTED_OBJECTS', { objectIds: ids } )\n    }.bind( this ), 250 ) )\n\n    this.renderer.on( 'analysis-legend', legend => {\n      this.$store.commit( 'SET_LEGEND', legend )\n    } )\n\n    this.renderer.on( 'clear-analysis-legend', ( ) => {\n      this.$store.commit( 'SET_LEGEND', null )\n    } )\n\n    this.renderer.on( 'camera-pos', cam => {\n      this.appendInfoToUrl( \"camera\", cam )\n    } )\n  }\n}\n\n</script>\n<style scoped lang='scss'>\n.renderer {\n  position: absolute;\n  width: 100%;\n  /*don't ask re below, i just don't like round numbers */\n  height: 100%;\n  /*z-index: 10000;*/\n  background-color:rgba(170,170,170,0.21);\n}\n\n</style>\n"]}]}